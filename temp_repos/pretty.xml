<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Python" filename="bitpay_cjdns/node_build/dependencies/libuv/build/gyp/tools/pretty_gyp.py"><comment type="hashbang">#!/usr/bin/env python</comment>

<comment type="line"># Copyright (c) 2012 Google Inc. All rights reserved.</comment>
<comment type="line"># Use of this source code is governed by a BSD-style license that can be</comment>
<comment type="line"># found in the LICENSE file.</comment>

<expr_stmt><expr><literal type="string">"""Pretty-prints the contents of a GYP file."""</literal></expr></expr_stmt>

<import>import <name>sys</name></import>
<import>import <name>re</name></import>


<comment type="line"># Regex to remove comments when we're counting braces.</comment>
<expr_stmt><expr><name>COMMENT_RE</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">r'\s*#.*'</literal></expr></argument>)</argument_list></call></expr></expr_stmt>

<comment type="line"># Regex to remove quoted strings when we're counting braces.</comment>
<comment type="line"># It takes into account quoted quotes, and makes sure that the quotes match.</comment>
<comment type="line"># NOTE: It does not handle quotes that span more than one line, or</comment>
<comment type="line"># cases where an escaped quote is preceeded by an escaped backslash.</comment>
<expr_stmt><expr><name>QUOTE_RE_STR</name> <operator>=</operator> <literal type="string">r'(?P&lt;q&gt;[\'"])(.*?)(?&lt;![^\\][\\])(?P=q)'</literal></expr></expr_stmt>
<expr_stmt><expr><name>QUOTE_RE</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><name>QUOTE_RE_STR</name></expr></argument>)</argument_list></call></expr></expr_stmt>


<function>def <name>comment_replace</name><parameter_list>(<parameter><name>matchobj</name></parameter>)</parameter_list><block>:<block_content>
  <return>return <expr><call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">'#'</literal> <operator>*</operator> <call><name>len</name><argument_list>(<argument><expr><call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></return>
</block_content></block></function>

<function>def <name>mask_comments</name><parameter_list>(<parameter><name>input</name></parameter>)</parameter_list><block>:<block_content>
  <expr_stmt><expr><literal type="string" format="docstring">"""Mask the quoted strings so we skip braces inside quoted strings."""</literal></expr></expr_stmt>
  <expr_stmt><expr><name>search_re</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">r'(.*?)(#)(.*)'</literal></expr></argument>)</argument_list></call></expr></expr_stmt>
  <return>return <expr><array>[<expr><call><name><name>search_re</name><operator>.</operator><name>sub</name></name><argument_list>(<argument><expr><name>comment_replace</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr> <comprehension><for>for <control><expr><name>line</name></expr> <range>in <expr><name>input</name></expr></range></control></for></comprehension>]</array></expr></return>
</block_content></block></function>

<function>def <name>quote_replace</name><parameter_list>(<parameter><name>matchobj</name></parameter>)</parameter_list><block>:<block_content>
  <return>return <expr><literal type="string">"%s%s%s%s"</literal> <operator>%</operator> <tuple>(<expr><call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
                       <expr><call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
                       <expr><literal type="string">'x'</literal><operator>*</operator><call><name>len</name><argument_list>(<argument><expr><call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
                       <expr><call><name><name>matchobj</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</tuple></expr></return>
</block_content></block></function>

<function>def <name>mask_quotes</name><parameter_list>(<parameter><name>input</name></parameter>)</parameter_list><block>:<block_content>
  <expr_stmt><expr><literal type="string" format="docstring">"""Mask the quoted strings so we skip braces inside quoted strings."""</literal></expr></expr_stmt>
  <expr_stmt><expr><name>search_re</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">r'(.*?)'</literal> <operator>+</operator> <name>QUOTE_RE_STR</name></expr></argument>)</argument_list></call></expr></expr_stmt>
  <return>return <expr><array>[<expr><call><name><name>search_re</name><operator>.</operator><name>sub</name></name><argument_list>(<argument><expr><name>quote_replace</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr> <comprehension><for>for <control><expr><name>line</name></expr> <range>in <expr><name>input</name></expr></range></control></for></comprehension>]</array></expr></return>
</block_content></block></function>

<function>def <name>do_split</name><parameter_list>(<parameter><name>input</name></parameter>, <parameter><name>masked_input</name></parameter>, <parameter><name>search_re</name></parameter>)</parameter_list><block>:<block_content>
  <expr_stmt><expr><name>output</name> <operator>=</operator> <array>[]</array></expr></expr_stmt>
  <expr_stmt><expr><name>mask_output</name> <operator>=</operator> <array>[]</array></expr></expr_stmt>
  <for>for <control><expr><tuple>(<expr><name>line</name></expr>, <expr><name>masked_line</name></expr>)</tuple></expr> <range>in <expr><call><name>zip</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>masked_input</name></expr></argument>)</argument_list></call></expr></range></control><block>:<block_content>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name><name>search_re</name><operator>.</operator><name>match</name></name><argument_list>(<argument><expr><name>masked_line</name></expr></argument>)</argument_list></call></expr></expr_stmt>
    <while>while <condition><expr><name>m</name></expr></condition><block>:<block_content>
      <expr_stmt><expr><name>split</name> <operator>=</operator> <call><name>len</name><argument_list>(<argument><expr><call><name><name>m</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></expr_stmt>
      <expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>line</name><index>[<expr><operator>:</operator><name>split</name></expr>]</index></name> <operator>+</operator> <literal type="string">r'\n'</literal> <operator>+</operator> <name><name>line</name><index>[<expr><name>split</name><operator>:</operator></expr>]</index></name></expr></expr_stmt>
      <expr_stmt><expr><name>masked_line</name> <operator>=</operator> <name><name>masked_line</name><index>[<expr><operator>:</operator><name>split</name></expr>]</index></name> <operator>+</operator> <literal type="string">r'\n'</literal> <operator>+</operator> <name><name>masked_line</name><index>[<expr><name>split</name><operator>:</operator></expr>]</index></name></expr></expr_stmt>
      <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name><name>search_re</name><operator>.</operator><name>match</name></name><argument_list>(<argument><expr><name>masked_line</name></expr></argument>)</argument_list></call></expr></expr_stmt>
</block_content></block></while>    <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><call><name><name>line</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><literal type="string">r'\n'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></expr_stmt>
    <expr_stmt><expr><call><name><name>mask_output</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><call><name><name>masked_line</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><literal type="string">r'\n'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></expr_stmt>
</block_content></block></for>  <return>return <expr><tuple>(<expr><name>output</name></expr>, <expr><name>mask_output</name></expr>)</tuple></expr></return>
</block_content></block></function>

<function>def <name>split_double_braces</name><parameter_list>(<parameter><name>input</name></parameter>)</parameter_list><block>:<block_content>
  <expr_stmt><expr><literal type="string" format="docstring">"""Masks out the quotes and comments, and then splits appropriate
  lines (lines that matche the double_*_brace re's above) before
  indenting them below.

  These are used to split lines which have multiple braces on them, so
  that the indentation looks prettier when all laid out (e.g. closing
  braces make a nice diagonal line).
  """</literal></expr></expr_stmt>
  <expr_stmt><expr><name>double_open_brace_re</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">r'(.*?[\[\{\(,])(\s*)([\[\{\(])'</literal></expr></argument>)</argument_list></call></expr></expr_stmt>
  <expr_stmt><expr><name>double_close_brace_re</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">r'(.*?[\]\}\)],?)(\s*)([\]\}\)])'</literal></expr></argument>)</argument_list></call></expr></expr_stmt>

  <expr_stmt><expr><name>masked_input</name> <operator>=</operator> <call><name>mask_quotes</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></expr_stmt>
  <expr_stmt><expr><name>masked_input</name> <operator>=</operator> <call><name>mask_comments</name><argument_list>(<argument><expr><name>masked_input</name></expr></argument>)</argument_list></call></expr></expr_stmt>

  <expr_stmt><expr><tuple>(<expr><name>output</name></expr>, <expr><name>mask_output</name></expr>)</tuple> <operator>=</operator> <call><name>do_split</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>masked_input</name></expr></argument>, <argument><expr><name>double_open_brace_re</name></expr></argument>)</argument_list></call></expr></expr_stmt>
  <expr_stmt><expr><tuple>(<expr><name>output</name></expr>, <expr><name>mask_output</name></expr>)</tuple> <operator>=</operator> <call><name>do_split</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>mask_output</name></expr></argument>, <argument><expr><name>double_close_brace_re</name></expr></argument>)</argument_list></call></expr></expr_stmt>

  <return>return <expr><name>output</name></expr></return>
</block_content></block></function>

<function>def <name>count_braces</name><parameter_list>(<parameter><name>line</name></parameter>)</parameter_list><block>:<block_content>
  <expr_stmt><expr><literal type="string" format="docstring">"""keeps track of the number of braces on a given line and returns the result.

  It starts at zero and subtracts for closed braces, and adds for open braces.
  """</literal></expr></expr_stmt>
  <expr_stmt><expr><name>open_braces</name> <operator>=</operator> <array>[<expr><literal type="string">'['</literal></expr>, <expr><literal type="string">'('</literal></expr>, <expr><literal type="string">'{'</literal></expr>]</array></expr></expr_stmt>
  <expr_stmt><expr><name>close_braces</name> <operator>=</operator> <array>[<expr><literal type="string">']'</literal></expr>, <expr><literal type="string">')'</literal></expr>, <expr><literal type="string">'}'</literal></expr>]</array></expr></expr_stmt>
  <expr_stmt><expr><name>closing_prefix_re</name> <operator>=</operator> <call><name><name>re</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">r'(.*?[^\s\]\}\)]+.*?)([\]\}\)],?)\s*$'</literal></expr></argument>)</argument_list></call></expr></expr_stmt>
  <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr></expr_stmt>
  <expr_stmt><expr><name>stripline</name> <operator>=</operator> <call><name><name>COMMENT_RE</name><operator>.</operator><name>sub</name></name><argument_list>(<argument><expr><literal type="string">r''</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></expr_stmt>
  <expr_stmt><expr><name>stripline</name> <operator>=</operator> <call><name><name>QUOTE_RE</name><operator>.</operator><name>sub</name></name><argument_list>(<argument><expr><literal type="string">r"''"</literal></expr></argument>, <argument><expr><name>stripline</name></expr></argument>)</argument_list></call></expr></expr_stmt>
  <for>for <control><expr><name>char</name></expr> <range>in <expr><name>stripline</name></expr></range></control><block>:<block_content>
    <for>for <control><expr><name>brace</name></expr> <range>in <expr><name>open_braces</name></expr></range></control><block>:<block_content>
      <if_stmt><if>if <condition><expr><name>char</name> <operator>==</operator> <name>brace</name></expr></condition><block>:<block_content>
        <expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">1</literal></expr></expr_stmt>
</block_content></block></if></if_stmt></block_content></block></for>    <for>for <control><expr><name>brace</name></expr> <range>in <expr><name>close_braces</name></expr></range></control><block>:<block_content>
      <if_stmt><if>if <condition><expr><name>char</name> <operator>==</operator> <name>brace</name></expr></condition><block>:<block_content>
        <expr_stmt><expr><name>cnt</name> <operator>-=</operator> <literal type="number">1</literal></expr></expr_stmt>
</block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
  <expr_stmt><expr><name>after</name> <operator>=</operator> <literal type="boolean">False</literal></expr></expr_stmt>
  <if_stmt><if>if <condition><expr><name>cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></condition><block>:<block_content>
    <expr_stmt><expr><name>after</name> <operator>=</operator> <literal type="boolean">True</literal></expr></expr_stmt>
</block_content></block></if></if_stmt>
  <comment type="line"># This catches the special case of a closing brace having something</comment>
  <comment type="line"># other than just whitespace ahead of it -- we don't want to</comment>
  <comment type="line"># unindent that until after this line is printed so it stays with</comment>
  <comment type="line"># the previous indentation level.</comment>
  <if_stmt><if>if <condition><expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>and</operator> <call><name><name>closing_prefix_re</name><operator>.</operator><name>match</name></name><argument_list>(<argument><expr><name>stripline</name></expr></argument>)</argument_list></call></expr></condition><block>:<block_content>
    <expr_stmt><expr><name>after</name> <operator>=</operator> <literal type="boolean">True</literal></expr></expr_stmt>
</block_content></block></if></if_stmt>  <return>return <expr><tuple>(<expr><name>cnt</name></expr>, <expr><name>after</name></expr>)</tuple></expr></return>
</block_content></block></function>

<function>def <name>prettyprint_input</name><parameter_list>(<parameter><name>lines</name></parameter>)</parameter_list><block>:<block_content>
  <expr_stmt><expr><literal type="string" format="docstring">"""Does the main work of indenting the input based on the brace counts."""</literal></expr></expr_stmt>
  <expr_stmt><expr><name>indent</name> <operator>=</operator> <literal type="number">0</literal></expr></expr_stmt>
  <expr_stmt><expr><name>basic_offset</name> <operator>=</operator> <literal type="number">2</literal></expr></expr_stmt>
  <expr_stmt><expr><name>last_line</name> <operator>=</operator> <literal type="string">""</literal></expr></expr_stmt>
  <for>for <control><expr><name>line</name></expr> <range>in <expr><name>lines</name></expr></range></control><block>:<block_content>
    <if_stmt><if>if <condition><expr><call><name><name>COMMENT_RE</name><operator>.</operator><name>match</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></condition><block>:<block_content>
      <print>print <expr><name>line</name></expr></print>
</block_content></block></if>    <else>else<block>:<block_content>
      <expr_stmt><expr><name>line</name> <operator>=</operator> <call><name><name>line</name><operator>.</operator><name>strip</name></name><argument_list>(<argument><expr><literal type="string">'\r\n\t '</literal></expr></argument>)</argument_list></call></expr></expr_stmt>  <comment type="line"># Otherwise doesn't strip \r on Unix.</comment>
      <if_stmt><if>if <condition><expr><call><name>len</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></condition><block>:<block_content>
        <expr_stmt><expr><tuple>(<expr><name>brace_diff</name></expr>, <expr><name>after</name></expr>)</tuple> <operator>=</operator> <call><name>count_braces</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></expr_stmt>
        <if_stmt><if>if <condition><expr><name>brace_diff</name> <operator>!=</operator> <literal type="number">0</literal></expr></condition><block>:<block_content>
          <if_stmt><if>if <condition><expr><name>after</name></expr></condition><block>:<block_content>
            <print>print <expr><literal type="string">" "</literal> <operator>*</operator> <operator>(</operator><name>basic_offset</name> <operator>*</operator> <name>indent</name><operator>)</operator> <operator>+</operator> <name>line</name></expr></print>
            <expr_stmt><expr><name>indent</name> <operator>+=</operator> <name>brace_diff</name></expr></expr_stmt>
</block_content></block></if>          <else>else<block>:<block_content>
            <expr_stmt><expr><name>indent</name> <operator>+=</operator> <name>brace_diff</name></expr></expr_stmt>
            <print>print <expr><literal type="string">" "</literal> <operator>*</operator> <operator>(</operator><name>basic_offset</name> <operator>*</operator> <name>indent</name><operator>)</operator> <operator>+</operator> <name>line</name></expr></print>
</block_content></block></else></if_stmt></block_content></block></if>        <else>else<block>:<block_content>
          <print>print <expr><literal type="string">" "</literal> <operator>*</operator> <operator>(</operator><name>basic_offset</name> <operator>*</operator> <name>indent</name><operator>)</operator> <operator>+</operator> <name>line</name></expr></print>
</block_content></block></else></if_stmt></block_content></block></if>      <else>else<block>:<block_content>
        <print>print <expr><literal type="string">""</literal></expr></print>
</block_content></block></else></if_stmt>      <expr_stmt><expr><name>last_line</name> <operator>=</operator> <name>line</name></expr></expr_stmt>
</block_content></block></else></if_stmt></block_content></block></for></block_content></block></function>

<function>def <name>main</name><parameter_list>()</parameter_list><block>:<block_content>
  <if_stmt><if>if <condition><expr><call><name>len</name><argument_list>(<argument><expr><name><name>sys</name><operator>.</operator><name>argv</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></condition><block>:<block_content>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>sys</name><operator>.</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>read</name><argument_list>()</argument_list></call><operator>.</operator><call><name>splitlines</name><argument_list>()</argument_list></call></expr></expr_stmt>
</block_content></block></if>  <else>else<block>:<block_content>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name><name>sys</name><operator>.</operator><name>stdin</name><operator>.</operator><name>read</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>splitlines</name><argument_list>()</argument_list></call></expr></expr_stmt>
</block_content></block></else></if_stmt>  <comment type="line"># Split up the double braces.</comment>
  <expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>split_double_braces</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></expr_stmt>

  <comment type="line"># Indent and print the output.</comment>
  <expr_stmt><expr><call><name>prettyprint_input</name><argument_list>(<argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr></expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr></return>
</block_content></block></function>

<if_stmt><if>if <condition><expr><name>__name__</name> <operator>==</operator> <literal type="string">'__main__'</literal></expr></condition><block>:<block_content>
  <expr_stmt><expr><call><name><name>sys</name><operator>.</operator><name>exit</name></name><argument_list>(<argument><expr><call><name>main</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></expr_stmt>
</block_content></block></if></if_stmt></unit>
